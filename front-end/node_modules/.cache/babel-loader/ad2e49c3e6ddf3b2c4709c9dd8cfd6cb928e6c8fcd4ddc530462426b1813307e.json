{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, watch, nextTick } from 'vue';\nimport { shouldIgnoreKey } from '../../utils/private/key-composition.js';\n\n// leave NAMED_MASKS at top of file (code referenced from docs)\nconst NAMED_MASKS = {\n  date: '####/##/##',\n  datetime: '####/##/## ##:##',\n  time: '##:##',\n  fulltime: '##:##:##',\n  phone: '(###) ### - ####',\n  card: '#### #### #### ####'\n};\nconst TOKENS = {\n  '#': {\n    pattern: '[\\\\d]',\n    negate: '[^\\\\d]'\n  },\n  S: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]'\n  },\n  N: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]'\n  },\n  A: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]',\n    transform: v => v.toLocaleUpperCase()\n  },\n  a: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]',\n    transform: v => v.toLocaleLowerCase()\n  },\n  X: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]',\n    transform: v => v.toLocaleUpperCase()\n  },\n  x: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]',\n    transform: v => v.toLocaleLowerCase()\n  }\n};\nconst KEYS = Object.keys(TOKENS);\nKEYS.forEach(key => {\n  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);\n});\nconst tokenRegexMask = new RegExp('\\\\\\\\([^.*+?^${}()|([\\\\]])|([.*+?^${}()|[\\\\]])|([' + KEYS.join('') + '])|(.)', 'g'),\n  escRegex = /[.*+?^${}()|[\\]\\\\]/g;\nconst MARKER = String.fromCharCode(1);\nexport const useMaskProps = {\n  mask: String,\n  reverseFillMask: Boolean,\n  fillMask: [Boolean, String],\n  unmaskedValue: Boolean\n};\nexport default function (props, emit, emitValue, inputRef) {\n  let maskMarked, maskReplaced, computedMask, computedUnmask;\n  const hasMask = ref(null);\n  const innerValue = ref(getInitialMaskedValue());\n  function getIsTypeText() {\n    return props.autogrow === true || ['textarea', 'text', 'search', 'url', 'tel', 'password'].includes(props.type);\n  }\n  watch(() => props.type + props.autogrow, updateMaskInternals);\n  watch(() => props.mask, v => {\n    if (v !== void 0) {\n      updateMaskValue(innerValue.value, true);\n    } else {\n      const val = unmaskValue(innerValue.value);\n      updateMaskInternals();\n      props.modelValue !== val && emit('update:modelValue', val);\n    }\n  });\n  watch(() => props.fillMask + props.reverseFillMask, () => {\n    hasMask.value === true && updateMaskValue(innerValue.value, true);\n  });\n  watch(() => props.unmaskedValue, () => {\n    hasMask.value === true && updateMaskValue(innerValue.value);\n  });\n  function getInitialMaskedValue() {\n    updateMaskInternals();\n    if (hasMask.value === true) {\n      const masked = maskValue(unmaskValue(props.modelValue));\n      return props.fillMask !== false ? fillWithMask(masked) : masked;\n    }\n    return props.modelValue;\n  }\n  function getPaddedMaskMarked(size) {\n    if (size < maskMarked.length) {\n      return maskMarked.slice(-size);\n    }\n    let pad = '',\n      localMaskMarked = maskMarked;\n    const padPos = localMaskMarked.indexOf(MARKER);\n    if (padPos > -1) {\n      for (let i = size - localMaskMarked.length; i > 0; i--) {\n        pad += MARKER;\n      }\n      localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos);\n    }\n    return localMaskMarked;\n  }\n  function updateMaskInternals() {\n    hasMask.value = props.mask !== void 0 && props.mask.length > 0 && getIsTypeText();\n    if (hasMask.value === false) {\n      computedUnmask = void 0;\n      maskMarked = '';\n      maskReplaced = '';\n      return;\n    }\n    const localComputedMask = NAMED_MASKS[props.mask] === void 0 ? props.mask : NAMED_MASKS[props.mask],\n      fillChar = typeof props.fillMask === 'string' && props.fillMask.length > 0 ? props.fillMask.slice(0, 1) : '_',\n      fillCharEscaped = fillChar.replace(escRegex, '\\\\$&'),\n      unmask = [],\n      extract = [],\n      mask = [];\n    let firstMatch = props.reverseFillMask === true,\n      unmaskChar = '',\n      negateChar = '';\n    localComputedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {\n      if (token !== void 0) {\n        const c = TOKENS[token];\n        mask.push(c);\n        negateChar = c.negate;\n        if (firstMatch === true) {\n          extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?');\n          firstMatch = false;\n        }\n        extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?');\n      } else if (esc !== void 0) {\n        unmaskChar = '\\\\' + (esc === '\\\\' ? '' : esc);\n        mask.push(esc);\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');\n      } else {\n        const c = char1 !== void 0 ? char1 : char2;\n        unmaskChar = c === '\\\\' ? '\\\\\\\\\\\\\\\\' : c.replace(escRegex, '\\\\\\\\$&');\n        mask.push(c);\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');\n      }\n    });\n    const unmaskMatcher = new RegExp('^' + unmask.join('') + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?' + (unmaskChar === '' ? '' : '[' + unmaskChar + ']*') + '$'),\n      extractLast = extract.length - 1,\n      extractMatcher = extract.map((re, index) => {\n        if (index === 0 && props.reverseFillMask === true) {\n          return new RegExp('^' + fillCharEscaped + '*' + re);\n        } else if (index === extractLast) {\n          return new RegExp('^' + re + '(' + (negateChar === '' ? '.' : negateChar) + '+)?' + (props.reverseFillMask === true ? '$' : fillCharEscaped + '*'));\n        }\n        return new RegExp('^' + re);\n      });\n    computedMask = mask;\n    computedUnmask = val => {\n      const unmaskMatch = unmaskMatcher.exec(props.reverseFillMask === true ? val : val.slice(0, mask.length));\n      if (unmaskMatch !== null) {\n        val = unmaskMatch.slice(1).join('');\n      }\n      const extractMatch = [],\n        extractMatcherLength = extractMatcher.length;\n      for (let i = 0, str = val; i < extractMatcherLength; i++) {\n        const m = extractMatcher[i].exec(str);\n        if (m === null) {\n          break;\n        }\n        str = str.slice(m.shift().length);\n        extractMatch.push(...m);\n      }\n      if (extractMatch.length > 0) {\n        return extractMatch.join('');\n      }\n      return val;\n    };\n    maskMarked = mask.map(v => typeof v === 'string' ? v : MARKER).join('');\n    maskReplaced = maskMarked.split(MARKER).join(fillChar);\n  }\n  function updateMaskValue(rawVal, updateMaskInternalsFlag, inputType) {\n    const inp = inputRef.value,\n      end = inp.selectionEnd,\n      endReverse = inp.value.length - end,\n      unmasked = unmaskValue(rawVal);\n\n    // Update here so unmask uses the original fillChar\n    updateMaskInternalsFlag === true && updateMaskInternals();\n    const preMasked = maskValue(unmasked),\n      masked = props.fillMask !== false ? fillWithMask(preMasked) : preMasked,\n      changed = innerValue.value !== masked;\n\n    // We want to avoid \"flickering\" so we set value immediately\n    inp.value !== masked && (inp.value = masked);\n    changed === true && (innerValue.value = masked);\n    document.activeElement === inp && nextTick(() => {\n      if (masked === maskReplaced) {\n        const cursor = props.reverseFillMask === true ? maskReplaced.length : 0;\n        inp.setSelectionRange(cursor, cursor, 'forward');\n        return;\n      }\n      if (inputType === 'insertFromPaste' && props.reverseFillMask !== true) {\n        const cursor = end - 1;\n        moveCursor.right(inp, cursor, cursor);\n        return;\n      }\n      if (['deleteContentBackward', 'deleteContentForward'].indexOf(inputType) > -1) {\n        const cursor = props.reverseFillMask === true ? end === 0 ? masked.length > preMasked.length ? 1 : 0 : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;\n        inp.setSelectionRange(cursor, cursor, 'forward');\n        return;\n      }\n      if (props.reverseFillMask === true) {\n        if (changed === true) {\n          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));\n          if (cursor === 1 && end === 1) {\n            inp.setSelectionRange(cursor, cursor, 'forward');\n          } else {\n            moveCursor.rightReverse(inp, cursor, cursor);\n          }\n        } else {\n          const cursor = masked.length - endReverse;\n          inp.setSelectionRange(cursor, cursor, 'backward');\n        }\n      } else {\n        if (changed === true) {\n          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);\n          moveCursor.right(inp, cursor, cursor);\n        } else {\n          const cursor = end - 1;\n          moveCursor.right(inp, cursor, cursor);\n        }\n      }\n    });\n    const val = props.unmaskedValue === true ? unmaskValue(masked) : masked;\n    String(props.modelValue) !== val && emitValue(val, true);\n  }\n  function moveCursorForPaste(inp, start, end) {\n    const preMasked = maskValue(unmaskValue(inp.value));\n    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));\n    inp.setSelectionRange(start, end, 'forward');\n  }\n  const moveCursor = {\n    left(inp, start, end, selection) {\n      const noMarkBefore = maskMarked.slice(start - 1).indexOf(MARKER) === -1;\n      let i = Math.max(0, start - 1);\n      for (; i >= 0; i--) {\n        if (maskMarked[i] === MARKER) {\n          start = i;\n          noMarkBefore === true && start++;\n          break;\n        }\n      }\n      if (i < 0 && maskMarked[start] !== void 0 && maskMarked[start] !== MARKER) {\n        return moveCursor.right(inp, 0, 0);\n      }\n      start >= 0 && inp.setSelectionRange(start, selection === true ? end : start, 'backward');\n    },\n    right(inp, start, end, selection) {\n      const limit = inp.value.length;\n      let i = Math.min(limit, end + 1);\n      for (; i <= limit; i++) {\n        if (maskMarked[i] === MARKER) {\n          end = i;\n          break;\n        } else if (maskMarked[i - 1] === MARKER) {\n          end = i;\n        }\n      }\n      if (i > limit && maskMarked[end - 1] !== void 0 && maskMarked[end - 1] !== MARKER) {\n        return moveCursor.left(inp, limit, limit);\n      }\n      inp.setSelectionRange(selection ? start : end, end, 'forward');\n    },\n    leftReverse(inp, start, end, selection) {\n      const localMaskMarked = getPaddedMaskMarked(inp.value.length);\n      let i = Math.max(0, start - 1);\n      for (; i >= 0; i--) {\n        if (localMaskMarked[i - 1] === MARKER) {\n          start = i;\n          break;\n        } else if (localMaskMarked[i] === MARKER) {\n          start = i;\n          if (i === 0) {\n            break;\n          }\n        }\n      }\n      if (i < 0 && localMaskMarked[start] !== void 0 && localMaskMarked[start] !== MARKER) {\n        return moveCursor.rightReverse(inp, 0, 0);\n      }\n      start >= 0 && inp.setSelectionRange(start, selection === true ? end : start, 'backward');\n    },\n    rightReverse(inp, start, end, selection) {\n      const limit = inp.value.length,\n        localMaskMarked = getPaddedMaskMarked(limit),\n        noMarkBefore = localMaskMarked.slice(0, end + 1).indexOf(MARKER) === -1;\n      let i = Math.min(limit, end + 1);\n      for (; i <= limit; i++) {\n        if (localMaskMarked[i - 1] === MARKER) {\n          end = i;\n          end > 0 && noMarkBefore === true && end--;\n          break;\n        }\n      }\n      if (i > limit && localMaskMarked[end - 1] !== void 0 && localMaskMarked[end - 1] !== MARKER) {\n        return moveCursor.leftReverse(inp, limit, limit);\n      }\n      inp.setSelectionRange(selection === true ? start : end, end, 'forward');\n    }\n  };\n  function onMaskedKeydown(e) {\n    if (shouldIgnoreKey(e) === true) {\n      return;\n    }\n    const inp = inputRef.value,\n      start = inp.selectionStart,\n      end = inp.selectionEnd;\n    if (e.keyCode === 37 || e.keyCode === 39) {\n      // Left / Right\n      const fn = moveCursor[(e.keyCode === 39 ? 'right' : 'left') + (props.reverseFillMask === true ? 'Reverse' : '')];\n      e.preventDefault();\n      fn(inp, start, end, e.shiftKey);\n    } else if (e.keyCode === 8 // Backspace\n    && props.reverseFillMask !== true && start === end) {\n      moveCursor.left(inp, start, end, true);\n    } else if (e.keyCode === 46 // Delete\n    && props.reverseFillMask === true && start === end) {\n      moveCursor.rightReverse(inp, start, end, true);\n    }\n  }\n  function maskValue(val) {\n    if (val === void 0 || val === null || val === '') {\n      return '';\n    }\n    if (props.reverseFillMask === true) {\n      return maskValueReverse(val);\n    }\n    const mask = computedMask;\n    let valIndex = 0,\n      output = '';\n    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {\n      const valChar = val[valIndex],\n        maskDef = mask[maskIndex];\n      if (typeof maskDef === 'string') {\n        output += maskDef;\n        valChar === maskDef && valIndex++;\n      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\n        output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;\n        valIndex++;\n      } else {\n        return output;\n      }\n    }\n    return output;\n  }\n  function maskValueReverse(val) {\n    const mask = computedMask,\n      firstTokenIndex = maskMarked.indexOf(MARKER);\n    let valIndex = val.length - 1,\n      output = '';\n    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {\n      const maskDef = mask[maskIndex];\n      let valChar = val[valIndex];\n      if (typeof maskDef === 'string') {\n        output = maskDef + output;\n        valChar === maskDef && valIndex--;\n      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\n        do {\n          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;\n          valIndex--;\n          valChar = val[valIndex];\n          // eslint-disable-next-line no-unmodified-loop-condition\n        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));\n      } else {\n        return output;\n      }\n    }\n    return output;\n  }\n  function unmaskValue(val) {\n    return typeof val !== 'string' || computedUnmask === void 0 ? typeof val === 'number' ? computedUnmask('' + val) : val : computedUnmask(val);\n  }\n  function fillWithMask(val) {\n    if (maskReplaced.length - val.length <= 0) {\n      return val;\n    }\n    return props.reverseFillMask === true && val.length > 0 ? maskReplaced.slice(0, -val.length) + val : val + maskReplaced.slice(val.length);\n  }\n  return {\n    innerValue,\n    hasMask,\n    moveCursorForPaste,\n    updateMaskValue,\n    onMaskedKeydown\n  };\n}","map":{"version":3,"names":["ref","watch","nextTick","shouldIgnoreKey","NAMED_MASKS","date","datetime","time","fulltime","phone","card","TOKENS","pattern","negate","S","N","A","transform","v","toLocaleUpperCase","a","toLocaleLowerCase","X","x","KEYS","Object","keys","forEach","key","regex","RegExp","tokenRegexMask","join","escRegex","MARKER","String","fromCharCode","useMaskProps","mask","reverseFillMask","Boolean","fillMask","unmaskedValue","props","emit","emitValue","inputRef","maskMarked","maskReplaced","computedMask","computedUnmask","hasMask","innerValue","getInitialMaskedValue","getIsTypeText","autogrow","includes","type","updateMaskInternals","updateMaskValue","value","val","unmaskValue","modelValue","masked","maskValue","fillWithMask","getPaddedMaskMarked","size","length","slice","pad","localMaskMarked","padPos","indexOf","i","localComputedMask","fillChar","fillCharEscaped","replace","unmask","extract","firstMatch","unmaskChar","negateChar","_","char1","esc","token","char2","c","push","unmaskMatcher","extractLast","extractMatcher","map","re","index","unmaskMatch","exec","extractMatch","extractMatcherLength","str","m","shift","split","rawVal","updateMaskInternalsFlag","inputType","inp","end","selectionEnd","endReverse","unmasked","preMasked","changed","document","activeElement","cursor","setSelectionRange","moveCursor","right","Math","max","min","rightReverse","moveCursorForPaste","start","left","selection","noMarkBefore","limit","leftReverse","onMaskedKeydown","e","selectionStart","keyCode","fn","preventDefault","shiftKey","maskValueReverse","valIndex","output","maskIndex","valChar","maskDef","test","firstTokenIndex"],"sources":["C:/Users/raamb/Desktop/MedicalBilling/front-end/node_modules/quasar/src/components/input/use-mask.js"],"sourcesContent":["import { ref, watch, nextTick } from 'vue'\r\n\r\nimport { shouldIgnoreKey } from '../../utils/private/key-composition.js'\r\n\r\n// leave NAMED_MASKS at top of file (code referenced from docs)\r\nconst NAMED_MASKS = {\r\n  date: '####/##/##',\r\n  datetime: '####/##/## ##:##',\r\n  time: '##:##',\r\n  fulltime: '##:##:##',\r\n  phone: '(###) ### - ####',\r\n  card: '#### #### #### ####'\r\n}\r\n\r\nconst TOKENS = {\r\n  '#': { pattern: '[\\\\d]', negate: '[^\\\\d]' },\r\n\r\n  S: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]' },\r\n  N: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]' },\r\n\r\n  A: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleUpperCase() },\r\n  a: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleLowerCase() },\r\n\r\n  X: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleUpperCase() },\r\n  x: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleLowerCase() }\r\n}\r\n\r\nconst KEYS = Object.keys(TOKENS)\r\nKEYS.forEach(key => {\r\n  TOKENS[ key ].regex = new RegExp(TOKENS[ key ].pattern)\r\n})\r\n\r\nconst\r\n  tokenRegexMask = new RegExp('\\\\\\\\([^.*+?^${}()|([\\\\]])|([.*+?^${}()|[\\\\]])|([' + KEYS.join('') + '])|(.)', 'g'),\r\n  escRegex = /[.*+?^${}()|[\\]\\\\]/g\r\n\r\nconst MARKER = String.fromCharCode(1)\r\n\r\nexport const useMaskProps = {\r\n  mask: String,\r\n  reverseFillMask: Boolean,\r\n  fillMask: [ Boolean, String ],\r\n  unmaskedValue: Boolean\r\n}\r\n\r\nexport default function (props, emit, emitValue, inputRef) {\r\n  let maskMarked, maskReplaced, computedMask, computedUnmask\r\n\r\n  const hasMask = ref(null)\r\n  const innerValue = ref(getInitialMaskedValue())\r\n\r\n  function getIsTypeText () {\r\n    return props.autogrow === true\r\n      || [ 'textarea', 'text', 'search', 'url', 'tel', 'password' ].includes(props.type)\r\n  }\r\n\r\n  watch(() => props.type + props.autogrow, updateMaskInternals)\r\n\r\n  watch(() => props.mask, v => {\r\n    if (v !== void 0) {\r\n      updateMaskValue(innerValue.value, true)\r\n    }\r\n    else {\r\n      const val = unmaskValue(innerValue.value)\r\n      updateMaskInternals()\r\n      props.modelValue !== val && emit('update:modelValue', val)\r\n    }\r\n  })\r\n\r\n  watch(() => props.fillMask + props.reverseFillMask, () => {\r\n    hasMask.value === true && updateMaskValue(innerValue.value, true)\r\n  })\r\n\r\n  watch(() => props.unmaskedValue, () => {\r\n    hasMask.value === true && updateMaskValue(innerValue.value)\r\n  })\r\n\r\n  function getInitialMaskedValue () {\r\n    updateMaskInternals()\r\n\r\n    if (hasMask.value === true) {\r\n      const masked = maskValue(unmaskValue(props.modelValue))\r\n\r\n      return props.fillMask !== false\r\n        ? fillWithMask(masked)\r\n        : masked\r\n    }\r\n\r\n    return props.modelValue\r\n  }\r\n\r\n  function getPaddedMaskMarked (size) {\r\n    if (size < maskMarked.length) {\r\n      return maskMarked.slice(-size)\r\n    }\r\n\r\n    let pad = '', localMaskMarked = maskMarked\r\n    const padPos = localMaskMarked.indexOf(MARKER)\r\n\r\n    if (padPos > -1) {\r\n      for (let i = size - localMaskMarked.length; i > 0; i--) {\r\n        pad += MARKER\r\n      }\r\n\r\n      localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos)\r\n    }\r\n\r\n    return localMaskMarked\r\n  }\r\n\r\n  function updateMaskInternals () {\r\n    hasMask.value = props.mask !== void 0\r\n      && props.mask.length > 0\r\n      && getIsTypeText()\r\n\r\n    if (hasMask.value === false) {\r\n      computedUnmask = void 0\r\n      maskMarked = ''\r\n      maskReplaced = ''\r\n      return\r\n    }\r\n\r\n    const\r\n      localComputedMask = NAMED_MASKS[ props.mask ] === void 0\r\n        ? props.mask\r\n        : NAMED_MASKS[ props.mask ],\r\n      fillChar = typeof props.fillMask === 'string' && props.fillMask.length > 0\r\n        ? props.fillMask.slice(0, 1)\r\n        : '_',\r\n      fillCharEscaped = fillChar.replace(escRegex, '\\\\$&'),\r\n      unmask = [],\r\n      extract = [],\r\n      mask = []\r\n\r\n    let\r\n      firstMatch = props.reverseFillMask === true,\r\n      unmaskChar = '',\r\n      negateChar = ''\r\n\r\n    localComputedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {\r\n      if (token !== void 0) {\r\n        const c = TOKENS[ token ]\r\n        mask.push(c)\r\n        negateChar = c.negate\r\n        if (firstMatch === true) {\r\n          extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?')\r\n          firstMatch = false\r\n        }\r\n        extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?')\r\n      }\r\n      else if (esc !== void 0) {\r\n        unmaskChar = '\\\\' + (esc === '\\\\' ? '' : esc)\r\n        mask.push(esc)\r\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?')\r\n      }\r\n      else {\r\n        const c = char1 !== void 0 ? char1 : char2\r\n        unmaskChar = c === '\\\\' ? '\\\\\\\\\\\\\\\\' : c.replace(escRegex, '\\\\\\\\$&')\r\n        mask.push(c)\r\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?')\r\n      }\r\n    })\r\n\r\n    const\r\n      unmaskMatcher = new RegExp(\r\n        '^'\r\n        + unmask.join('')\r\n        + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?'\r\n        + (unmaskChar === '' ? '' : '[' + unmaskChar + ']*') + '$'\r\n      ),\r\n      extractLast = extract.length - 1,\r\n      extractMatcher = extract.map((re, index) => {\r\n        if (index === 0 && props.reverseFillMask === true) {\r\n          return new RegExp('^' + fillCharEscaped + '*' + re)\r\n        }\r\n        else if (index === extractLast) {\r\n          return new RegExp(\r\n            '^' + re\r\n            + '(' + (negateChar === '' ? '.' : negateChar) + '+)?'\r\n            + (props.reverseFillMask === true ? '$' : fillCharEscaped + '*')\r\n          )\r\n        }\r\n\r\n        return new RegExp('^' + re)\r\n      })\r\n\r\n    computedMask = mask\r\n    computedUnmask = val => {\r\n      const unmaskMatch = unmaskMatcher.exec(props.reverseFillMask === true ? val : val.slice(0, mask.length))\r\n      if (unmaskMatch !== null) {\r\n        val = unmaskMatch.slice(1).join('')\r\n      }\r\n\r\n      const\r\n        extractMatch = [],\r\n        extractMatcherLength = extractMatcher.length\r\n\r\n      for (let i = 0, str = val; i < extractMatcherLength; i++) {\r\n        const m = extractMatcher[ i ].exec(str)\r\n\r\n        if (m === null) {\r\n          break\r\n        }\r\n\r\n        str = str.slice(m.shift().length)\r\n        extractMatch.push(...m)\r\n      }\r\n      if (extractMatch.length > 0) {\r\n        return extractMatch.join('')\r\n      }\r\n\r\n      return val\r\n    }\r\n    maskMarked = mask.map(v => (typeof v === 'string' ? v : MARKER)).join('')\r\n    maskReplaced = maskMarked.split(MARKER).join(fillChar)\r\n  }\r\n\r\n  function updateMaskValue (rawVal, updateMaskInternalsFlag, inputType) {\r\n    const\r\n      inp = inputRef.value,\r\n      end = inp.selectionEnd,\r\n      endReverse = inp.value.length - end,\r\n      unmasked = unmaskValue(rawVal)\r\n\r\n    // Update here so unmask uses the original fillChar\r\n    updateMaskInternalsFlag === true && updateMaskInternals()\r\n\r\n    const\r\n      preMasked = maskValue(unmasked),\r\n      masked = props.fillMask !== false\r\n        ? fillWithMask(preMasked)\r\n        : preMasked,\r\n      changed = innerValue.value !== masked\r\n\r\n    // We want to avoid \"flickering\" so we set value immediately\r\n    inp.value !== masked && (inp.value = masked)\r\n\r\n    changed === true && (innerValue.value = masked)\r\n\r\n    document.activeElement === inp && nextTick(() => {\r\n      if (masked === maskReplaced) {\r\n        const cursor = props.reverseFillMask === true ? maskReplaced.length : 0\r\n        inp.setSelectionRange(cursor, cursor, 'forward')\r\n\r\n        return\r\n      }\r\n\r\n      if (inputType === 'insertFromPaste' && props.reverseFillMask !== true) {\r\n        const cursor = end - 1\r\n        moveCursor.right(inp, cursor, cursor)\r\n\r\n        return\r\n      }\r\n\r\n      if ([ 'deleteContentBackward', 'deleteContentForward' ].indexOf(inputType) > -1) {\r\n        const cursor = props.reverseFillMask === true\r\n          ? (\r\n              end === 0\r\n                ? (masked.length > preMasked.length ? 1 : 0)\r\n                : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1\r\n            )\r\n          : end\r\n\r\n        inp.setSelectionRange(cursor, cursor, 'forward')\r\n        return\r\n      }\r\n\r\n      if (props.reverseFillMask === true) {\r\n        if (changed === true) {\r\n          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)))\r\n\r\n          if (cursor === 1 && end === 1) {\r\n            inp.setSelectionRange(cursor, cursor, 'forward')\r\n          }\r\n          else {\r\n            moveCursor.rightReverse(inp, cursor, cursor)\r\n          }\r\n        }\r\n        else {\r\n          const cursor = masked.length - endReverse\r\n          inp.setSelectionRange(cursor, cursor, 'backward')\r\n        }\r\n      }\r\n      else {\r\n        if (changed === true) {\r\n          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1)\r\n          moveCursor.right(inp, cursor, cursor)\r\n        }\r\n        else {\r\n          const cursor = end - 1\r\n          moveCursor.right(inp, cursor, cursor)\r\n        }\r\n      }\r\n    })\r\n\r\n    const val = props.unmaskedValue === true\r\n      ? unmaskValue(masked)\r\n      : masked\r\n\r\n    String(props.modelValue) !== val && emitValue(val, true)\r\n  }\r\n\r\n  function moveCursorForPaste (inp, start, end) {\r\n    const preMasked = maskValue(unmaskValue(inp.value))\r\n\r\n    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start))\r\n\r\n    inp.setSelectionRange(start, end, 'forward')\r\n  }\r\n\r\n  const moveCursor = {\r\n    left (inp, start, end, selection) {\r\n      const noMarkBefore = maskMarked.slice(start - 1).indexOf(MARKER) === -1\r\n      let i = Math.max(0, start - 1)\r\n\r\n      for (; i >= 0; i--) {\r\n        if (maskMarked[ i ] === MARKER) {\r\n          start = i\r\n          noMarkBefore === true && start++\r\n          break\r\n        }\r\n      }\r\n\r\n      if (\r\n        i < 0\r\n        && maskMarked[ start ] !== void 0\r\n        && maskMarked[ start ] !== MARKER\r\n      ) {\r\n        return moveCursor.right(inp, 0, 0)\r\n      }\r\n\r\n      start >= 0 && inp.setSelectionRange(\r\n        start,\r\n        selection === true ? end : start, 'backward'\r\n      )\r\n    },\r\n\r\n    right (inp, start, end, selection) {\r\n      const limit = inp.value.length\r\n      let i = Math.min(limit, end + 1)\r\n\r\n      for (; i <= limit; i++) {\r\n        if (maskMarked[ i ] === MARKER) {\r\n          end = i\r\n          break\r\n        }\r\n        else if (maskMarked[ i - 1 ] === MARKER) {\r\n          end = i\r\n        }\r\n      }\r\n\r\n      if (\r\n        i > limit\r\n        && maskMarked[ end - 1 ] !== void 0\r\n        && maskMarked[ end - 1 ] !== MARKER\r\n      ) {\r\n        return moveCursor.left(inp, limit, limit)\r\n      }\r\n\r\n      inp.setSelectionRange(selection ? start : end, end, 'forward')\r\n    },\r\n\r\n    leftReverse (inp, start, end, selection) {\r\n      const\r\n        localMaskMarked = getPaddedMaskMarked(inp.value.length)\r\n      let i = Math.max(0, start - 1)\r\n\r\n      for (; i >= 0; i--) {\r\n        if (localMaskMarked[ i - 1 ] === MARKER) {\r\n          start = i\r\n          break\r\n        }\r\n        else if (localMaskMarked[ i ] === MARKER) {\r\n          start = i\r\n          if (i === 0) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (\r\n        i < 0\r\n        && localMaskMarked[ start ] !== void 0\r\n        && localMaskMarked[ start ] !== MARKER\r\n      ) {\r\n        return moveCursor.rightReverse(inp, 0, 0)\r\n      }\r\n\r\n      start >= 0 && inp.setSelectionRange(\r\n        start,\r\n        selection === true ? end : start, 'backward'\r\n      )\r\n    },\r\n\r\n    rightReverse (inp, start, end, selection) {\r\n      const\r\n        limit = inp.value.length,\r\n        localMaskMarked = getPaddedMaskMarked(limit),\r\n        noMarkBefore = localMaskMarked.slice(0, end + 1).indexOf(MARKER) === -1\r\n      let i = Math.min(limit, end + 1)\r\n\r\n      for (; i <= limit; i++) {\r\n        if (localMaskMarked[ i - 1 ] === MARKER) {\r\n          end = i\r\n          end > 0 && noMarkBefore === true && end--\r\n          break\r\n        }\r\n      }\r\n\r\n      if (\r\n        i > limit\r\n        && localMaskMarked[ end - 1 ] !== void 0\r\n        && localMaskMarked[ end - 1 ] !== MARKER\r\n      ) {\r\n        return moveCursor.leftReverse(inp, limit, limit)\r\n      }\r\n\r\n      inp.setSelectionRange(selection === true ? start : end, end, 'forward')\r\n    }\r\n  }\r\n\r\n  function onMaskedKeydown (e) {\r\n    if (shouldIgnoreKey(e) === true) {\r\n      return\r\n    }\r\n\r\n    const\r\n      inp = inputRef.value,\r\n      start = inp.selectionStart,\r\n      end = inp.selectionEnd\r\n\r\n    if (e.keyCode === 37 || e.keyCode === 39) { // Left / Right\r\n      const fn = moveCursor[ (e.keyCode === 39 ? 'right' : 'left') + (props.reverseFillMask === true ? 'Reverse' : '') ]\r\n\r\n      e.preventDefault()\r\n      fn(inp, start, end, e.shiftKey)\r\n    }\r\n    else if (\r\n      e.keyCode === 8 // Backspace\r\n      && props.reverseFillMask !== true\r\n      && start === end\r\n    ) {\r\n      moveCursor.left(inp, start, end, true)\r\n    }\r\n    else if (\r\n      e.keyCode === 46 // Delete\r\n      && props.reverseFillMask === true\r\n      && start === end\r\n    ) {\r\n      moveCursor.rightReverse(inp, start, end, true)\r\n    }\r\n  }\r\n\r\n  function maskValue (val) {\r\n    if (val === void 0 || val === null || val === '') { return '' }\r\n\r\n    if (props.reverseFillMask === true) {\r\n      return maskValueReverse(val)\r\n    }\r\n\r\n    const mask = computedMask\r\n\r\n    let valIndex = 0, output = ''\r\n\r\n    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {\r\n      const\r\n        valChar = val[ valIndex ],\r\n        maskDef = mask[ maskIndex ]\r\n\r\n      if (typeof maskDef === 'string') {\r\n        output += maskDef\r\n        valChar === maskDef && valIndex++\r\n      }\r\n      else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\r\n        output += maskDef.transform !== void 0\r\n          ? maskDef.transform(valChar)\r\n          : valChar\r\n        valIndex++\r\n      }\r\n      else {\r\n        return output\r\n      }\r\n    }\r\n\r\n    return output\r\n  }\r\n\r\n  function maskValueReverse (val) {\r\n    const\r\n      mask = computedMask,\r\n      firstTokenIndex = maskMarked.indexOf(MARKER)\r\n\r\n    let valIndex = val.length - 1, output = ''\r\n\r\n    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {\r\n      const maskDef = mask[ maskIndex ]\r\n\r\n      let valChar = val[ valIndex ]\r\n\r\n      if (typeof maskDef === 'string') {\r\n        output = maskDef + output\r\n        valChar === maskDef && valIndex--\r\n      }\r\n      else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\r\n        do {\r\n          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output\r\n          valIndex--\r\n          valChar = val[ valIndex ]\r\n        // eslint-disable-next-line no-unmodified-loop-condition\r\n        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar))\r\n      }\r\n      else {\r\n        return output\r\n      }\r\n    }\r\n\r\n    return output\r\n  }\r\n\r\n  function unmaskValue (val) {\r\n    return typeof val !== 'string' || computedUnmask === void 0\r\n      ? (typeof val === 'number' ? computedUnmask('' + val) : val)\r\n      : computedUnmask(val)\r\n  }\r\n\r\n  function fillWithMask (val) {\r\n    if (maskReplaced.length - val.length <= 0) {\r\n      return val\r\n    }\r\n\r\n    return props.reverseFillMask === true && val.length > 0\r\n      ? maskReplaced.slice(0, -val.length) + val\r\n      : val + maskReplaced.slice(val.length)\r\n  }\r\n\r\n  return {\r\n    innerValue,\r\n    hasMask,\r\n    moveCursorForPaste,\r\n    updateMaskValue,\r\n    onMaskedKeydown\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}